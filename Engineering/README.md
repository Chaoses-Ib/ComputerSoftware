# Software Engineering
## Crisis
**Software crisis** is a term used in the early days of computing science for the difficulty of writing useful and efficient computer programs in the required time.[^crisis-wiki]

[Big ball of mud](https://en.wikipedia.org/wiki/Big_ball_of_mud):
> A Big Ball of Mud is a haphazardly structured, sprawling, sloppy, duct-tape-and-baling-wire, spaghetti-code jungle. These systems show unmistakable signs of unregulated growth, and repeated, expedient repair. Information is shared promiscuously among distant elements of the system, often to the point where nearly all the important information becomes global or duplicated.

[Small matter of programming](https://en.wikipedia.org/wiki/Small_matter_of_programming):
> **Small matter of programming** (**SMOP**) or **simple matter of programming** is a phrase used to ironically indicate that a suggested feature or design change would in fact require a great deal of effort.

[Software disenchantment @ tonsky.me](https://tonsky.me/blog/disenchantment/)

## Philosophies
[List of software development philosophies - Wikipedia](https://en.wikipedia.org/wiki/List_of_software_development_philosophies)

- [300 Rules of Thumb and Nuggets of Wisdom](https://www.managingtheunmanageable.net/morerulesofthumb.html)

- [DWIM](https://en.wikipedia.org/wiki/DWIM)

  > DWIM (do what I mean) computer systems attempt to anticipate what users intend to do, correcting trivial errors automatically rather than blindly executing users' explicit but potentially incorrect input.

- [Fail-fast](https://en.wikipedia.org/wiki/Fail-fast)

  > A fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure.

- [Gall's law](https://en.wikipedia.org/wiki/Gall%27s_law)

  > A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system.

- [If it ain't broke, don't fix it](https://en.wikipedia.org/wiki/If_it_ain%27t_broke,_don%27t_fix_it)

- [KISS principle](https://en.wikipedia.org/wiki/KISS_principle)

  > Keep it simple, stupid!

- [Law of conservation of complexity](https://en.wikipedia.org/wiki/Law_of_conservation_of_complexity)

  > The **law of conservation of complexity** (**Tesler's Law**, **Waterbed Theory**) is an adage in human–computer interaction stating that every application has an inherent amount of complexity that cannot be removed or hidden. Instead, it must be dealt with, either in product development or in user interaction.

- [Lehman's laws of software evolution](https://en.wikipedia.org/wiki/Lehman%27s_laws_of_software_evolution)

  > - "Continuing Change" — an E-type system must be continually adapted or it becomes progressively less satisfactory.
  > - "Increasing Complexity" — as an E-type system evolves, its complexity increases unless work is done to maintain or reduce it.
  > - "Self Regulation" — E-type system evolution processes are self-regulating with the distribution of product and process measures close to normal.
  > - "Conservation of Organisational Stability (invariant work rate)" — the average effective global activity rate in an evolving E-type system is invariant over the product's lifetime.
  > - "Conservation of Familiarity" — as an E-type system evolves, all associated with it, developers, sales personnel and users, for example, must maintain mastery of its content and behaviour to achieve satisfactory evolution. Excessive growth diminishes that mastery. Hence the average incremental growth remains invariant as the system evolves.
  > - "Continuing Growth" — the functional content of an E-type system must be continually increased to maintain user satisfaction over its lifetime.
  > - "Declining Quality" — the quality of an E-type system will appear to be declining unless it is rigorously maintained and adapted to operational environment changes.
  > - "Feedback System" — E-type evolution processes constitute multi-level, multi-loop, multi-agent feedback systems and must be treated as such to achieve significant improvement over any reasonable base.

- [Loose coupling](https://en.wikipedia.org/wiki/Loose_coupling)

  > A loosely coupled system is one
  > 1. in which components are weakly associated (have breakable relationships) with each other, and thus changes in one component least affect existence or performance of another component.
  > 2. in which each of its components has, or makes use of, little or no knowledge of the definitions of other separate components. Subareas include the coupling of classes, interfaces, data, and services.

- [Minimalism](https://en.wikipedia.org/wiki/Minimalism_(computing))

  > Minimalism means designing systems that use the least hardware and software resources possible.

- [Ninety–ninety rule](https://en.wikipedia.org/wiki/Ninety%E2%80%93ninety_rule)

  > The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time.

- [Open–closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)

  > Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.

- [Principle of least astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)

  > The **principle of least astonishment (POLA)**, also known as **principle of least surprise**, proposes that a component of a system should behave in a way that most users will expect it to behave, and therefore not astonish or surprise users. The following is a corollary of the principle: "If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature."

- [Release early, release often](https://en.wikipedia.org/wiki/Release_early,_release_often)

- [Robustness principle](https://en.wikipedia.org/wiki/Robustness_principle)

  > Be conservative in what you do, be liberal in what you accept from others.

- [Rule of least power](https://en.wikipedia.org/wiki/Rule_of_least_power)

  > Choose the least powerful \[computer\] language suitable for a given purpose.

- [Separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns)

  > Separation of concerns is a design principle for separating a computer program into distinct sections.

- [Separation of mechanism and policy](https://en.wikipedia.org/wiki/Separation_of_mechanism_and_policy)

  > Mechanisms (those parts of a system implementation that control the authorization of operations and the allocation of resources) should not dictate (or overly restrict) the policies according to which decisions are made about which operations to authorize, and which resources to allocate.

- [Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy)

  > 1. Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new "features".
  > 2. Expect the output of every program to become the input to another, as yet unknown, program. Don't clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don't insist on interactive input.
  > 3. Design and build software, even operating systems, to be tried early, ideally within weeks. Don't hesitate to throw away the clumsy parts and rebuild them.
  > 4. Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you've finished using them.

- [Worse is better](https://en.wikipedia.org/wiki/Worse_is_better)

  > Software that is limited, but simple to use, may be more appealing to the user and market than the reverse.

- [There's more than one way to do it](https://en.wikipedia.org/wiki/Perl#Philosophy)

- [You aren't gonna need it](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)

  > Always implement things when you actually need them, never when you just foresee that you \[will\] need them. It is hard for less experienced developers to appreciate how rarely architecting for future requirements / applications turns out net-positive.

Normalization:
- [Code reuse](https://en.wikipedia.org/wiki/Code_reuse)

- [Don't repeat yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)

  > "Don't repeat yourself" (DRY) is a principle aimed at reducing repetition of information which is likely to change, replacing it with abstractions that are less likely to change, or using data normalization which avoids redundancy in the first place.

- [Single source of truth](https://en.wikipedia.org/wiki/Single_source_of_truth)

- [Single version of the truth](https://en.wikipedia.org/wiki/Single_version_of_the_truth)

- [Uniform access principle](https://en.wikipedia.org/wiki/Uniform_access_principle)

## Engineering
**Software engineering** is a systematic engineering approach to software development.[^wiki]

[Software Engineering Method and Theory](https://en.wikipedia.org/wiki/SEMAT) is an initiative to reshape software engineering such that software engineering qualifies as a rigorous discipline.

Laws:
- [Conway's law](https://en.wikipedia.org/wiki/Conway%27s_law)

  > Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.

Patterns:
- [Egoless programming](https://en.wikipedia.org/wiki/Egoless_programming)

  > Egoless programming is a style of computer programming in which personal factors are minimized so that quality may be improved.

## [Capability Maturity Model](https://en.wikipedia.org/wiki/Capability_Maturity_Model)
Levels:
1. Initial
   
   It is characteristic of processes at this level that they are (typically) undocumented and in a state of dynamic change, tending to be driven in an ad hoc, uncontrolled and reactive manner by users or events. This provides a chaotic or unstable environment for the processes. (Example - a surgeon performing a new operation a small number of times - the levels of negative outcome are not known).

2. Repeatable
   
   It is characteristic of this level of maturity that some processes are repeatable, possibly with consistent results. Process discipline is unlikely to be rigorous, but where it exists it may help to ensure that existing processes are maintained during times of stress.

3. Defined
   
   It is characteristic of processes at this level that there are sets of defined and documented standard processes established and subject to some degree of improvement over time. These standard processes are in place. The processes may not have been systematically or repeatedly used - sufficient for the users to become competent or the process to be validated in a range of situations. This could be considered a developmental stage - with use in a wider range of conditions and user competence development the process can develop to next level of maturity.

4. Managed (Capable)
   
   It is characteristic of processes at this level that, using process metrics, effective achievement of the process objectives can be evidenced across a range of operational conditions. The suitability of the process in multiple environments has been tested and the process refined and adapted. Process users have experienced the process in multiple and varied conditions, and are able to demonstrate competence. The process maturity enables adaptions to particular projects without measurable losses of quality or deviations from specifications. Process Capability is established from this level. (Example - surgeon performing an operation hundreds of times with levels of negative outcome approaching zero).

5. Optimizing (Efficient)
   
   It is a characteristic of processes at this level that the focus is on continually improving process performance through both incremental and innovative technological changes/improvements. At maturity level 5, processes are concerned with addressing statistical common causes of process variation and changing the process (for example, to shift the mean of the process performance) to improve process performance. This would be done at the same time as maintaining the likelihood of achieving the established quantitative process-improvement objectives.


[^crisis-wiki]: [Software crisis - Wikipedia](https://en.wikipedia.org/wiki/Software_crisis)
[^wiki]: [Software engineering - Wikipedia](https://en.wikipedia.org/wiki/Software_engineering)