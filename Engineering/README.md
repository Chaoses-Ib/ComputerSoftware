# Software Engineering
## Crisis
**Software crisis** is a term used in the early days of computing science for the difficulty of writing useful and efficient computer programs in the required time.[^crisis-wiki]

[Big ball of mud](https://en.wikipedia.org/wiki/Big_ball_of_mud):
> A Big Ball of Mud is a haphazardly structured, sprawling, sloppy, duct-tape-and-baling-wire, spaghetti-code jungle. These systems show unmistakable signs of unregulated growth, and repeated, expedient repair. Information is shared promiscuously among distant elements of the system, often to the point where nearly all the important information becomes global or duplicated.

[Small matter of programming](https://en.wikipedia.org/wiki/Small_matter_of_programming):
> **Small matter of programming** (**SMOP**) or **simple matter of programming** is a phrase used to ironically indicate that a suggested feature or design change would in fact require a great deal of effort.

[Software disenchantment @ tonsky.me](https://tonsky.me/blog/disenchantment/)

## Philosophies
[List of software development philosophies - Wikipedia](https://en.wikipedia.org/wiki/List_of_software_development_philosophies)

- [300 Rules of Thumb and Nuggets of Wisdom](https://www.managingtheunmanageable.net/morerulesofthumb.html)

- [DWIM](https://en.wikipedia.org/wiki/DWIM)

  > DWIM (do what I mean) computer systems attempt to anticipate what users intend to do, correcting trivial errors automatically rather than blindly executing users' explicit but potentially incorrect input.

- [Fail-fast](https://en.wikipedia.org/wiki/Fail-fast)

  > A fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure.

- [Gall's law](https://en.wikipedia.org/wiki/Gall%27s_law)

  > A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system.

- [If it ain't broke, don't fix it](https://en.wikipedia.org/wiki/If_it_ain%27t_broke,_don%27t_fix_it)

- [KISS principle](https://en.wikipedia.org/wiki/KISS_principle)

  > Keep it simple, stupid!

- [Law of conservation of complexity](https://en.wikipedia.org/wiki/Law_of_conservation_of_complexity)

  > The **law of conservation of complexity** (**Tesler's Law**, **Waterbed Theory**) is an adage in human–computer interaction stating that every application has an inherent amount of complexity that cannot be removed or hidden. Instead, it must be dealt with, either in product development or in user interaction.

- [Lehman's laws of software evolution](https://en.wikipedia.org/wiki/Lehman%27s_laws_of_software_evolution)

  > - "Continuing Change" — an E-type system must be continually adapted or it becomes progressively less satisfactory.
  > - "Increasing Complexity" — as an E-type system evolves, its complexity increases unless work is done to maintain or reduce it.
  > - "Self Regulation" — E-type system evolution processes are self-regulating with the distribution of product and process measures close to normal.
  > - "Conservation of Organisational Stability (invariant work rate)" — the average effective global activity rate in an evolving E-type system is invariant over the product's lifetime.
  > - "Conservation of Familiarity" — as an E-type system evolves, all associated with it, developers, sales personnel and users, for example, must maintain mastery of its content and behaviour to achieve satisfactory evolution. Excessive growth diminishes that mastery. Hence the average incremental growth remains invariant as the system evolves.
  > - "Continuing Growth" — the functional content of an E-type system must be continually increased to maintain user satisfaction over its lifetime.
  > - "Declining Quality" — the quality of an E-type system will appear to be declining unless it is rigorously maintained and adapted to operational environment changes.
  > - "Feedback System" — E-type evolution processes constitute multi-level, multi-loop, multi-agent feedback systems and must be treated as such to achieve significant improvement over any reasonable base.

- [Loose coupling](https://en.wikipedia.org/wiki/Loose_coupling)

  > A loosely coupled system is one
  > 1. in which components are weakly associated (have breakable relationships) with each other, and thus changes in one component least affect existence or performance of another component.
  > 2. in which each of its components has, or makes use of, little or no knowledge of the definitions of other separate components. Subareas include the coupling of classes, interfaces, data, and services.

- [Minimalism](https://en.wikipedia.org/wiki/Minimalism_(computing))

  > Minimalism means designing systems that use the least hardware and software resources possible.

- [Ninety–ninety rule](https://en.wikipedia.org/wiki/Ninety%E2%80%93ninety_rule)

  > The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time.

- [Open–closed principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)

  > Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.

- [Principle of least astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)

  > The **principle of least astonishment (POLA)**, also known as **principle of least surprise**, proposes that a component of a system should behave in a way that most users will expect it to behave, and therefore not astonish or surprise users. The following is a corollary of the principle: "If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature."

- [Release early, release often](https://en.wikipedia.org/wiki/Release_early,_release_often)

- [Robustness principle](https://en.wikipedia.org/wiki/Robustness_principle)

  > Be conservative in what you do, be liberal in what you accept from others.

- [Rule of least power](https://en.wikipedia.org/wiki/Rule_of_least_power)

  > Choose the least powerful \[computer\] language suitable for a given purpose.

- [Separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns)

  > Separation of concerns is a design principle for separating a computer program into distinct sections.

- [Separation of mechanism and policy](https://en.wikipedia.org/wiki/Separation_of_mechanism_and_policy)

  > Mechanisms (those parts of a system implementation that control the authorization of operations and the allocation of resources) should not dictate (or overly restrict) the policies according to which decisions are made about which operations to authorize, and which resources to allocate.

- [Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy)

  > 1. Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new "features".
  > 2. Expect the output of every program to become the input to another, as yet unknown, program. Don't clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don't insist on interactive input.
  > 3. Design and build software, even operating systems, to be tried early, ideally within weeks. Don't hesitate to throw away the clumsy parts and rebuild them.
  > 4. Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you've finished using them.

- [Worse is better](https://en.wikipedia.org/wiki/Worse_is_better)

  > Software that is limited, but simple to use, may be more appealing to the user and market than the reverse.

- [There's more than one way to do it](https://en.wikipedia.org/wiki/Perl#Philosophy)

- [You aren't gonna need it](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)

  > Always implement things when you actually need them, never when you just foresee that you \[will\] need them. It is hard for less experienced developers to appreciate how rarely architecting for future requirements / applications turns out net-positive.

Normalization:
- [Code reuse](https://en.wikipedia.org/wiki/Code_reuse)

- [Don't repeat yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)

  > "Don't repeat yourself" (DRY) is a principle aimed at reducing repetition of information which is likely to change, replacing it with abstractions that are less likely to change, or using data normalization which avoids redundancy in the first place.

- [Single source of truth](https://en.wikipedia.org/wiki/Single_source_of_truth)

- [Single version of the truth](https://en.wikipedia.org/wiki/Single_version_of_the_truth)

- [Uniform access principle](https://en.wikipedia.org/wiki/Uniform_access_principle)

## Engineering
**Software engineering** is a systematic engineering approach to software development.[^wiki]

[Software Engineering Method and Theory](https://en.wikipedia.org/wiki/SEMAT) is an initiative to reshape software engineering such that software engineering qualifies as a rigorous discipline.

Laws:
- [Conway's law](https://en.wikipedia.org/wiki/Conway%27s_law)

  > Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.

Patterns:
- [Agile software development](https://en.wikipedia.org/wiki/Agile_software_development)

  > Agile practices include requirements discovery and solutions improvement through the collaborative effort of self-organizing and cross-functional teams with their customer(s)/end user(s).

- [Cowboy coding](https://en.wikipedia.org/wiki/Cowboy_coding)

  > Cowboy coding is software development where programmers have autonomy over the development process. This includes control of the project's schedule, languages, algorithms, tools, frameworks and coding style. Typically, little to no coordination exists with other developers or stakeholders.

- [Egoless programming](https://en.wikipedia.org/wiki/Egoless_programming)

  > Egoless programming is a style of computer programming in which personal factors are minimized so that quality may be improved.

- [Extreme programming](https://en.wikipedia.org/wiki/Extreme_programming)

  > **Extreme programming (XP)** is a software development methodology intended to improve software quality and responsiveness to changing customer requirements. As a type of agile software development, it advocates frequent releases in short development cycles, intended to improve productivity and introduce checkpoints at which new customer requirements can be adopted.

[^crisis-wiki]: [Software crisis - Wikipedia](https://en.wikipedia.org/wiki/Software_crisis)
[^wiki]: [Software engineering - Wikipedia](https://en.wikipedia.org/wiki/Software_engineering)